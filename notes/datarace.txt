# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=datarace-cs-noneg-dlog

.include "AS.dom"
.include "F.dom"
.include "E.dom"
.include "H.dom"
.include "M.dom"
.include "L.dom"
.include "K.dom"
.include "C.dom"
.include "I.dom"

.bddvarorder L0_F0_E0_E1_M0_AS0xAS1_H0_K0_C0xC1xC2_I0

###
# Relations
###

unlockedRaceHext(t1:AS0,c1:C0,e1:E0,t2:AS1,c2:C1,e2:E1) input

###

EF(e:E0,f:F0) input
statF(f:F0) input
statE(e:E0)
CEC(c:C0,e:E0,o:C1) input		
escapingRaceHext(t1:AS0,c1:C0,e1:E0,t2:AS1,c2:C1,e2:E1) output

###

mhe_cs(c:C0,e:E0,t1:AS0,t2:AS1) input
parallelRaceHext(t1:AS0,c1:C0,e1:E0,t2:AS1,c2:C1,e2:E1) output

###

excludeSameThread(k:K0) input
datarace(t1:AS0,c1:C0,e1:E0,t2:AS1,c2:C1,e2:E1) output
racePairs_cs(e1:E0,e2:E1) output

###
# Constraints
###

statE(e) :- EF(e,f), statF(f).

escapingRaceHext(t1,c1,e1,t2,c2,e2) :- unlockedRaceHext(t1,c1,e1,t2,c2,e2), \
	CEC(c1,e1,o), CEC(c2,e2,o).
escapingRaceHext(t1,c1,e1,t2,c2,e2) :- unlockedRaceHext(t1,c1,e1,t2,c2,e2), \
	statE(e1), statE(e2).

###

parallelRaceHext(t1,c1,e1,t2,c2,e2) :- escapingRaceHext(t1,c1,e1,t2,c2,e2), \
	mhe_cs(c1,e1,t1,t2), mhe_cs(c2,e2,t2,t1).

###

datarace(t1,c1,e1,t2,c2,e2) :- parallelRaceHext(t1,c1,e1,t2,c2,e2), excludeSameThread(1), t1!=t2.
datarace(t1,c1,e1,t2,c2,e2) :- parallelRaceHext(t1,c1,e1,t2,c2,e2), excludeSameThread(0).


racePairs_cs(e1,e2) :- datarace(_,_,e1,_,_,e2).

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=datarace-parallel-include-cs-dlog

.include "AS.dom"
.include "C.dom"
.include "E.dom"
.include "P.dom"

.bddvarorder E0_AS0xAS1_P0_C0

###
# Relations
###

PE(p:P0,e:E0) input
mhp_cs(c:C0,p:P0,t1:AS0,t2:AS1) input
mhe_cs(c:C0,e:E0,t1:AS0,t2:AS1) output

mhe_cs(c,e,t1,t2) :- mhp_cs(c,p,t1,t2), PE(p,e).

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=mhp-cs-dlog

.include "AS.dom"
.include "C.dom"
.include "I.dom"
.include "M.dom"
.include "P.dom"
.include "V.dom"
.include "Z.dom"

.bddvarorder AS0xAS1xAS2_I0xM0xM1xP0xP1xP2_C0xC1

###
# Relations
###

PP(p:P,q:P) input
MPhead(m:M,p:P) input
MPtail(m:M,p:P) input
PI(p:P,i:I) input
CICM(c1:C,i:I,c2:C,m:M) input
threadACM(t:AS,c:C,m:M) input
threadStartI(i:I) input
threadCICM(c:C,i:I,c:C,m:M) input
threadAC(t:AS,c:C) 
threadACH(t:AS,c:C,h:P)

threadPM_cs   (caller:C,p1:P,callee:C) output
threadPH_cs   (caller:C,p1:P,callee:C,p2:P) output
simplePM_cs(caller:C,p1:P,callee:C,m2:M) output
simplePH_cs(caller:C,p1:P,callee:C,p2:P) output
simplePT_cs(caller:C,p1:P,callee:C,p2:P) output

PathEdge_cs(c:C,p:P,this:AS,sThat:AS,tThat:AS) output
# defined only for ordinary calls p (not thread start calls)
SummEdge_cs(c:C,p:P,this:AS,sThat:AS,tThat:AS) output

mhp_cs(c:C,p:P,t1:AS,t2:AS) output

###
# Constraints
###

simplePM_cs(c,p,d,m) :- CICM(c,i,d,m), PI(p,i), !threadStartI(i).
simplePH_cs(c,p,d,h) :- simplePM_cs(c,p,d,m), MPhead(m,h).
simplePT_cs(c,p,d,t) :- simplePM_cs(c,p,d,m), MPtail(m,t).
threadPM_cs(c,p,d) :- threadCICM(c,i,d,_), PI(p,i).
threadPH_cs(c,p,d,h) :- threadCICM(c,i,d,m), PI(p,i), MPhead(m,h).
threadAC(t,c) :- threadACM(t,c,m), m!=0.
threadACH(t,c,h) :- threadACM(t,c,m), m!=0, MPhead(m,h).

# PathEdge(c,p,this,sThat,tThat) 
# There exists a unique method m such that:
# 1. it is invoked in a context c and
# 2. it contains node p
# Above predicate denotes a path edge for [c,m]:
# from dataflow fact (this,sThat) at head node of m
# to   dataflow fact (this,tThat) at node p

PathEdge_cs(0,0,1,0,0).

# assumptions about relation PP:
# it does not contain edges from call nodes to head nodes
# it does not contain edges from tail nodes to call nodes
PathEdge_cs(c,q,t,t1,t2) :- PathEdge_cs(c,p,t,t1,t2), PP(p,q).

# ordinary calls

PathEdge_cs(d,q,t,t1,t2) :- simplePH_cs(c,p,d,q) , PathEdge_cs(c,p,t,_ ,t2), t1=t2.
SummEdge_cs(c,p,t,t1,t2) :- simplePT_cs(c,p,d,q) , PathEdge_cs(d,q,t,t1,t2).
PathEdge_cs(c,r,t,t1,t3) :- SummEdge_cs(c,p,t,t2,t3), PathEdge_cs(c,p,t,t1,t2), PP(p,r).

# thread fork calls

PathEdge_cs(c,r,t,t1,t2) :- threadPM_cs(c,p,d), PathEdge_cs(c,p,t,t1,_), PP(p,r), threadAC(t2,d).
#PathEdge_cs(c,r,t,t1,t3) :- threadPM_cs(c,p,d), PathEdge_cs(c,p,t,t1,_), \
#	PP(p,r), threadAC(t2,d), PathEdge_cs(d,q,t2,0,t3), MPtail(1,q). 

# Avoid split versions of rules for MLNs
#PathEdge_cs(d,h,x,y,z) :- threadPH_cs(c,p,d,h), PathEdge_cs(c,p,y,_,_), threadAC(x,d), z=y. split
#PathEdge_cs(d,h,x,y,z) :- threadPH_cs(c,p,d,h), PathEdge_cs(c,p,_,_,y), threadAC(x,d), z=y. split
#PathEdge_cs(e,h1,x,y,z) :- threadPM_cs(c,p,d), PathEdge_cs(c,p,_,_,x), threadACH(x,e,h1), threadAC(y,d), z=y. split

PathEdge_cs(d,h,x,y,z) :- threadPH_cs(c,p,d,h), PathEdge_cs(c,p,y,_,_), threadAC(x,d), z=y.
PathEdge_cs(d,h,x,y,z) :- threadPH_cs(c,p,d,h), PathEdge_cs(c,p,_,_,y), threadAC(x,d), z=y.
PathEdge_cs(e,h1,x,y,z) :- threadPM_cs(c,p,d), PathEdge_cs(c,p,_,_,x), threadACH(x,e,h1), threadAC(y,d), z=y.

mhp_cs(c,p,t1,t2) :- PathEdge_cs(c,p,t1,_,t2), t1!=0, t2!=0.

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=flowins-thresc-cs-dlog

.include "M.dom"
.include "V.dom"
.include "C.dom"
.include "P.dom"
.include "Z.dom"
.include "F.dom"
.include "E.dom"
.include "T.dom"
.include "H.dom"

.bddvarorder E0_M0xP0_V0_C0_F0_C1_Z0_T0_H0_H1

###
# Relations
###

#VH(v:V0,h:H0) input
#FH(f:F,h:H) input
#HFH(h1:H0,f:F0,h2:H1) input

CVC(c1:C0,v:V0,c2:C1) input
FC(f:F,c:C) input
CFC(c1:C,f:F,c2:C) input
MmethArg(m:M,z:Z,v:V) input
#MV(m:M,v:V) input
#MP(m:M,p:P) input
EV(e:E,v:V) input
escE(e:E) input

escO(o:C) output
#escCPVO(c:C,p:P,v:V,o:C) output
CEC(c:C0,e:E0,o:C1) output

#escH_cs(o:H) output
#escPVH_cs(p:P,v:V,h:H) output

###
# Constraints
###

#escH_cs(h) :- FH(_,h).
#escH_cs(h) :- MmethArg(1,0,v), VH(v,h).
#escH_cs(h2) :- HFH(h1,_,h2), escH_cs(h1).

#escPVH_cs(p,v,h) :- VH(v,h), MV(m,v), MP(m,p), escH_cs(h). split


escO(o) :- FC(_,o).
escO(o) :- MmethArg(1,0,v), CVC(_,v,o).
escO(o2) :- CFC(o1,_,o2), escO(o1).

#escCPVO(c,p,v,o) :- CVC(c,v,o), MV(m,v), MP(m,p), escO(o). split
#escCPVO(c,p,v,o) :- CVC(c,v,o), MV(m,v), MP(m,p), escO(o).

# For FSE'15
#CEC(c,e,o) :- CVC(c,v,o), EV(e,v), escO(o).

CEC(c,e,o) :- CVC(c,v,o), EV(e,v), escO(o), escE(e).

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=datarace-cs-init-dlog

.include "AS.dom"
.include "F.dom"
.include "E.dom"
.include "H.dom"
.include "M.dom"
.include "L.dom"
.include "K.dom"
.include "C.dom"
.include "I.dom"
.include "V.dom"

.bddvarorder L0_F0_E0_E1_M0_AS0xAS1_H0_K0_C0xC1xC2_I0_V0

###
# Relations
###

excludeInitMethods(k:K0) input
initM(m:M0) input

###

writeE(e:E0) input
ME(m:M0,e:E0) input
EF(e:E0,f:F0) input
reachableACM(t:AS0,c:C0,m:M0) input
checkExcludedM(m:M0) input

excludeInitM(m:M0)
relevantTCM(t:AS0,c:C0,m:M0)
relevantTCE(t:AS0,c:C0,e:E0)

rdOrWrTCEF(t:AS0,c:C0,e:E0,f:F0)
onlyWrTCEF(t:AS0,c:C0,e:E0,f:F0)

###

syncC(c:C1) input
unlockedE_cs(t:AS0,c1:C0,e:E0,c2:C1) input

###

unlikelyRaceHext(t1:AS0,c1:C0,e1:E0,t2:AS1,c2:C1,e2:E1)
startingRaceHext(t1:AS0,c1:C0,e1:E0,t2:AS1,c2:C1,e2:E1)
unlockedRaceHext(t1:AS0,c1:C0,e1:E0,t2:AS1,c2:C1,e2:E1) output

###
# Constraints
###

##For eliminating negation from datarace-cs

excludeInitM(m) :- excludeInitMethods(1), initM(m).

relevantTCM(t,c,m) :- reachableACM(t,c,m), !checkExcludedM(m), !excludeInitM(m).

relevantTCE(t,c,e) :- relevantTCM(t,c,m), ME(m,e).

rdOrWrTCEF(t,c,e,f) :- relevantTCE(t,c,e), EF(e,f).
onlyWrTCEF(t,c,e,f) :- relevantTCE(t,c,e), EF(e,f), writeE(e).

startingRaceHext(t1,c1,e1,t2,c2,e2) :- onlyWrTCEF(t1,c1,e1,f), rdOrWrTCEF(t2,c2,e2,f), e1 < e2.
startingRaceHext(t1,c1,e1,t2,c2,e2) :- rdOrWrTCEF(t1,c1,e1,f), onlyWrTCEF(t2,c2,e2,f), e1 < e2.
startingRaceHext(t1,c1,e1,t2,c2,e2) :- onlyWrTCEF(t1,c1,e1,f), onlyWrTCEF(t2,c2,e2,f), \
	e1 = e2, c1 < c2.
startingRaceHext(t1,c1,e1,t2,c2,e2) :- onlyWrTCEF(t1,c1,e1,f), onlyWrTCEF(t2,c2,e2,f), \
	e1 = e2, c1 = c2, t1 <= t2.
ctxtInsStartingRace(e1,e2) :- startingRaceHext(_,_,e1,_,_,e2).


guardedE(t,c,e,o) :- syncC(o), !unlockedE_cs(t,c,e,o).

unlikelyRaceHext(t1,c1,e1,t2,c2,e2) :- startingRaceHext(t1,c1,e1,t2,c2,e2), \
	guardedE(t1,c1,e1,o), guardedE(t2,c2,e2,o).

unlockedRaceHext(t1,c1,e1,t2,c2,e2) :- startingRaceHext(t1,c1,e1,t2,c2,e2), \
	!unlikelyRaceHext(t1,c1,e1,t2,c2,e2).

================================================================================

package chord.analyses.escape.cs;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;

import joeq.Class.jq_Method;
import joeq.Compiler.Quad.Operator;
import joeq.Compiler.Quad.Quad;
import joeq.Compiler.Quad.Operand.RegisterOperand;
import joeq.Compiler.Quad.Operator.ALoad;
import joeq.Compiler.Quad.Operator.AStore;
import joeq.Compiler.Quad.Operator.Getfield;
import joeq.Compiler.Quad.Operator.Putfield;
import joeq.Compiler.Quad.RegisterFactory.Register;
import chord.analyses.heapacc.DomE;
import chord.analyses.var.DomV;
import chord.project.Chord;
import chord.project.ClassicProject;
import chord.project.analyses.JavaAnalysis;
import chord.project.analyses.ProgramRel;

/**
 *
 * @author Ravi Mangal
 */
@Chord(
    name = "escE-java",
    consumes = {"E", "V", "checkExcludedE"},
    produces = {"escE"}
)
public class EscE extends JavaAnalysis {
	
	public void run() {
		DomE domE = (DomE) ClassicProject.g().getTrgt("E");
        DomV domV = (DomV) ClassicProject.g().getTrgt("V");
        ProgramRel relEscE = (ProgramRel) ClassicProject.g().getTrgt("escE");
        relEscE.zero();  
        Map<String, Quad> strToQuadMap = new HashMap<String, Quad>();
        for(int idx = 0; idx < domE.size(); idx++){
			Quad q = (Quad) domE.get(idx);
			strToQuadMap.put(q.toByteLocStr(), q);
		}
        
        HashSet<Quad> skipThrEscE = new HashSet<Quad>();
        
        if(Boolean.getBoolean("chord.mln.useThrEsc")) {
        	//built set skipThrEscE
        	String thrEscFile = System.getProperty("chord.mln.threscFile");
        	if (thrEscFile != null) {
        		try {
        			Scanner sc = new Scanner(new File(thrEscFile));
        			while(sc.hasNextLine()){
        				String nextLine = sc.nextLine();
        				Quad q = strToQuadMap.get(nextLine);
        				skipThrEscE.add(q);
        				//        			skipThrEscE.add((Quad) domE.get(Integer.parseInt(nextLine)));
        			}
        			sc.close();
        		} catch (FileNotFoundException e) {
        			throw new RuntimeException(e);
        		}
        	}

//        	ProgramRel relCheckExcludedE = (ProgramRel) ClassicProject.g().getTrgt("checkExcludedE");
//        	relCheckExcludedE.load();
//        	Iterable<Quad> tuples = relCheckExcludedE.getAry1ValTuples();
//        	for (Quad t : tuples) {
//        		skipThrEscE.add(t);
//        	}
//        	relCheckExcludedE.close();
        }

		ProgramRel relCheckExcludedE = (ProgramRel) ClassicProject.g().getTrgt("checkExcludedE");
		relCheckExcludedE.load();
		Iterable<Quad> tuples = relCheckExcludedE.getAry1ValTuples();
		for (Quad t : tuples) {
			skipThrEscE.add(t);
		}
		relCheckExcludedE.close();
        
        int numE = domE.size();
        for (int eIdx = 0; eIdx < numE; eIdx++) {
            Quad q = (Quad) domE.get(eIdx);
        	if (skipThrEscE.contains(q)) continue;
            relEscE.add(eIdx);
        }
        relEscE.save();
	}   
}

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=datarace-nongrded-include-cs-dlog

.include "AS.dom"
.include "C.dom"
.include "I.dom"
.include "M.dom"
.include "V.dom"
.include "E.dom"
.include "L.dom"
.include "F.dom"
.include "T.dom"

.bddvarorder L0_E0_F0_AS0_I0xM0_T0_V0_C0xC1_C2

###
# Relations
###

MI(m:M0,i:I0) input
ME(m:M0,e:E0) input
thrSenCICM(c:C0,i:I0,d:C1,m:M0) input
threadACM(t:AS0,c:C0,m:M0) input

transLI(l:L0,i:I0) input
transLE(l:L0,e:E0) input
threadStartI(i:I) input

invkLock(c:C0,i:I0,o:C1)
elemLock(c:C0,e:E0,o:C1)
syncC(c:C1) input

syncCLC(c:C0,l:L0,o:C1) input

unlockedM(t:AS0,c1:C1,m:M0,c2:C2) 
unlockedI(t:AS0,c1:C0,i:I0,c2:C2) 
unlockedE_cs(t:AS0,c1:C0,e:E0,c2:C1) output

###
# Constraints
###
invkLock(c,i,o) :- transLI(l,i), syncCLC(c,l,o).
elemLock(c,e,o) :- transLE(l,e), syncCLC(c,l,o).

unlockedM(t,c,m,o) :- syncC(o), threadACM(t,c,m).

unlockedI(t,d,i,o) :- unlockedM(t,d,m,o), MI(m,i), !invkLock(d,i,o), !threadStartI(i).
unlockedM(t,d,n,o) :- unlockedI(t,c,i,o), thrSenCICM(c,i,d,n).

unlockedE_cs(t,c,e,o) :- unlockedM(t,c,m,o), ME(m,e), !elemLock(c,e,o).

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=syncCLC-dlog

.include "C.dom"
.include "M.dom"
.include "V.dom"
.include "L.dom"
.include "F.dom"
.include "T.dom"

.bddvarorder L0_F0_M0_T0_V0_C0xC1_C2

###
# Relations
###

CVC(c:C0,v:V0,o:C1) input
thisMV(m:M0,v:V0) input
syncLM(l:L0,m:M0) input
syncLV(l:L0,v:V0) input

syncCLC(c:C0,l:L0,o:C1) output
syncC(c:C1) output

###
# Constraints
###

syncCLC(c,l,o) :- syncLM(l,m), thisMV(m,v), CVC(c,v,o).
syncCLC(c,l,o) :- syncLV(l,v), CVC(c,v,o).
syncC(o) :- syncCLC(_,_,o).

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=reachableACM-dlog

.include "M.dom"
.include "I.dom"
.include "AS.dom"
.include "C.dom"

.bddvarorder AS0_I0xI1xM0xM1_C0xC1xC2

###
# Relations
###

thrSenCICM(c:C0,i:I0,d:C1,m:M0) input
threadACM(t:AS0,o:C0,m:M0) input
MI(m:M0,i:I0) input
threadStartI(i:I0) input

reachableACM(t:AS0,c:C0,m:M0) output
threadReachableM_cs(m:M0) output

###
# Constraints
###

reachableACM(t,c,m) :- threadACM(t,c,m).
#reachableACM(t,d,n) :- reachableACM(t,c,m), MI(m,i), thrSenCICM(c,i,d,n), !threadStartI(i).
reachableACM(t,d,n) :- reachableACM(t,c,m), MI(m,i), thrSenCICM(c,i,d,n).

threadReachableM_cs(m) :- reachableACM(_,_,m).

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=thrSenCSCG-dlog

.include "I.dom"
.include "M.dom"
.include "C.dom"

.bddvarorder I0xM0xM1xM2xC0xC1xC2

###
# Relations
###

rootCM(c:C,m:M) input
threadCICM(c:C,i:I,c:C,m:M) input
threadStartI(i:I) input
CICM(c:C,i:I,d:C,m:M) input
MI(m:M,i:I) input

thrSenRootCM(c:C,m:M) output
thrSenReachableCM(c:C,m:M) output
thrSenCICM(c:C,i:I,c:C,m:M) output
thrSenCMCM(c:C,m:M,c:C,n:M) output

###
# Constraints
###

thrSenRootCM(c,m) :- rootCM(c,m).
thrSenRootCM(c,m) :- threadCICM(_,_,c,m).

thrSenReachableCM(c,m) :- thrSenRootCM(c,m).
thrSenReachableCM(d,n) :- thrSenCICM(_,_,d,n).

thrSenCICM(c,i,d,n) :- thrSenReachableCM(c,m), MI(m,i), CICM(c,i,d,n), !threadStartI(i).
thrSenCMCM(c,m,d,n) :- thrSenCICM(c,i,d,n), MI(m,i).

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# k-CFA may-alias/call-graph analysis.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=soft-cspa-kcfa-dlog

.include "F.dom"
.include "H.dom"
.include "I.dom"
.include "M.dom"
.include "T.dom"
.include "V.dom"
.include "Z.dom"
.include "C.dom"

.bddvarorder F0_I0xM0xM1_T0_V0xV1_T1_H0_C0xC1xC2_Z0

###
# Relations
###

HT(h:H0,t:T1) input
cha(n:M1,t:T1,m:M0) input
sub(t1:T1,t2:T0) input
MI(m:M,i:I) input
statIM(i:I,m:M) input
specIM(i:I,m:M) input
virtIM(i:I,m:M) input

MobjValAsgnInst(m:M,l:V,h:H) input
MobjVarAsgnInst(m:M,l:V,r:V) input
MgetInstFldInst(m:M,l:V,b:V,f:F) input
MputInstFldInst(m:M,b:V,f:F,r:V) input
MgetStatFldInst(m:M,l:V,f:F) input
MputStatFldInst(m:M,f:F,r:V) input

clsForNameIT(i:I0,t:T0) input
objNewInstIH(i:I0,h:H0) input
objNewInstIM(i:I0,m:M0) input
conNewInstIH(i:I0,h:H0) input
conNewInstIM(i:I0,m:M0) input
aryNewInstIH(i:I0,h:H0) input

RobjValAsgnInst(c:C,l:V,h:H) output
RobjVarAsgnInst(c:C,l:V,r:V) output
RgetInstFldInst(c:C,l:V,b:V,f:F) output
RputInstFldInst(c:C,b:V,f:F,r:V) output
RgetStatFldInst(c:C,l:V,f:F) output
RputStatFldInst(c:C,f:F,r:V) output

classT(t:T) input
staticTM(t:T,m:M) input
staticTF(t:T,f:F) input
clinitTM(t:T,m:M) input
MmethArg(m:M0,n:Z0,v:V0) input
IinvkArg(i:I0,n:Z0,v:V1) input
IinvkArg0(i:I0,v:V1) input
IinvkRet(i:I0,n:Z0,v:V0) input
argCopy(i:I0,u:V1,m:M0,v:V0) input
retCopy(i:I0,u:V0,m:M0,v:V1) input
VCfilter(v:V,c:C) input

#CC(c:C,d:C) input # d = [* c]
CH(c:C,h:H) input # c = [h ...]
#CI(c:C,i:I) input # c = [i ...]
epsilonM(m:M) input # treat method m context insensitively
kcfaSenM(m:M) input # treat method m context sensitively

IHM(i:I,h:H,m:M) output # at call site i, if h is the allocation site of "this" argument, can get to method m
reachableT(t:T) output

kcfaDIC(c:C,i:I,c:C) output
DIC(c:C,i:I,c:C) output # in context c, at call site i, c can be the "this" argument
DIH(c:C,i:I,h:H) output
DI(c:C,i:I) output

DVDV(c:C0,u:V0,d:C1,v:V1) output # u in context c can point to same stuff as v in context d

ctxtInsIHM(i:I,h:H,m:M) output
kcfaSenIHM(i:I,h:H,m:M) output

ctxtInsSpecIM(i:I,m:M) output
kcfaSenSpecIM(i:I,m:M) output

ctxtInsStatIM(i:I,m:M) output
kcfaSenStatIM(i:I,m:M) output

reachableCI(c:C,i:I) output
reachableCM(c:C,m:M) output

rootCM(c:C,m:M) output
CICM(c:C,i:I,d:C,m:M) output # in context c, call site i can call method m in context d
CMCM(c:C,m:M,d:C,n:M) output # true if exists some i in m

CVC(c1:C,v:V,c2:C) output # in context c1, variable v can point to abstract object c2

FC(f:F,c:C) output # static field can point to abstract object c2
CFC(c1:C,f:F,c2:C) output # abstract object c1 can point to abstract object c2 via field f

CIC(c:C,i:I,d:C) input # d = [i, c]
CHC(c:C,h:H,d:C) input # d = [h, c]

###
# Constraints
###

#CIC(c,i,d) :- CC(c,d), CI(d,i).
#CHC(c,h,d) :- CC(c,d), CH(d,h).

###

IHM(i,h,m2) :- virtIM(i,m1), HT(h,t), cha(m1,t,m2).
ctxtInsIHM(i,h,m) :- IHM(i,h,m), epsilonM(m).
kcfaSenIHM(i,h,m) :- IHM(i,h,m), kcfaSenM(m).

kcfaSenSpecIM(i,m) :- specIM(i,m), kcfaSenM(m).
ctxtInsSpecIM(i,m) :- specIM(i,m), epsilonM(m).

kcfaSenStatIM(i,m) :- statIM(i,m), kcfaSenM(m).
ctxtInsStatIM(i,m) :- statIM(i,m), epsilonM(m).

###

reachableCM(0,0).
reachableCM(0,m) :- clinitTM(t,m), reachableT(t).
reachableCM(c,m) :- CICM(_,_,c,m).
reachableCI(c,i) :- MI(m,i), reachableCM(c,m).

###

DIC(c,i,o) :- IinvkArg0(i,v), CVC(c,v,o).
DIH(c,i,h) :- DIC(c,i,o), CH(o,h).
DI(c,i) :- DIH(c,i,_).

kcfaDIC(0,i,d) :- CIC(0,i,d), MI(m,i), epsilonM(m).
kcfaDIC(c,i,d) :- CIC(c,i,d), MI(m,i), kcfaSenM(m).

###

CICM(c,i,0,m) :- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
CICM(c,i,d,m) :- reachableCI(c,i), kcfaSenIHM(i,h,m), DIH(c,i,h), kcfaDIC(c,i,d).

CICM(c,i,0,m) :- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
CICM(c,i,d,m) :- reachableCI(c,i), kcfaSenSpecIM(i,m), DI(c,i), kcfaDIC(c,i,d).

CICM(c,i,0,m) :- reachableCI(c,i), ctxtInsStatIM(i,m).
CICM(c,i,d,m) :- reachableCI(c,i), kcfaSenStatIM(i,m), kcfaDIC(c,i,d).

### inter-procedural

DVDV(d,v,c,u) :- argCopy(i,u,m,v), CICM(c,i,d,m).
DVDV(c,u,d,v) :- retCopy(i,u,m,v), CICM(c,i,d,m).

CVC(c,u,o) :- DVDV(c,u,d,v), CVC(d,v,o), VCfilter(u,o).

### in context c, l = new h

RobjValAsgnInst(c,l,h) :- reachableCM(c,m), MobjValAsgnInst(m,l,h).
CVC(c,l,o) :- RobjValAsgnInst(c,l,h), CHC(c,h,o).

### in context c, l = r

RobjVarAsgnInst(c,l,r) :- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
CVC(c,l,c1) :- RobjVarAsgnInst(c,l,r), CVC(c,r,c1), VCfilter(l,c1).

### in context c, l = b.f

RgetInstFldInst(c,l,b,f) :- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
CVC(c,l,c2) :- RgetInstFldInst(c,l,b,f), CVC(c,b,c1), CFC(c1,f,c2). split

### in context c, l = STATIC.f

RgetStatFldInst(c,l,f) :- reachableCM(c,m), MgetStatFldInst(m,l,f).
CVC(c,l,o) :- RgetStatFldInst(c,l,f), FC(f,o).

### in context c, b.f = r

RputInstFldInst(c,b,f,r) :- reachableCM(c,m), MputInstFldInst(m,b,f,r).
CFC(c1,f,c2) :- RputInstFldInst(c,b,f,r), CVC(c,b,c1), CVC(c,r,c2). split

### in context c, STATIC.f = r

RputStatFldInst(c,f,r) :- reachableCM(c,m), MputStatFldInst(m,f,r).
FC(f,o) :- RputStatFldInst(c,f,r), CVC(c,r,o).

### reflection handling rules

reachableCM(c,m) :- reachableCI(c,i), objNewInstIM(i,m).
reachableCM(c,m) :- reachableCI(c,i), conNewInstIM(i,m).

CVC(c,v,o)  :- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
CVC(c,v,o)  :- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
CVC(c,v,o2) :- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), CVC(c,u,o), CFC(o,0,o2).
CVC(c,v,o)  :- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
CVC(c,v,o)  :- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
CVC(c,v,o)  :- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).

### rules propagating reachableT

reachableT(t) :- reachableCI(_,i), conNewInstIH(i,h), HT(h,t).
reachableT(t) :- reachableCI(_,i), objNewInstIH(i,h), HT(h,t).
reachableT(t) :- reachableCI(_,i), clsForNameIT(i,t).

reachableT(t) :- reachableCM(_,m), MobjValAsgnInst(m,_,h), HT(h,t).
reachableT(t) :- reachableCM(_,m), staticTM(t,m).
reachableT(t) :- reachableCM(_,m), MputStatFldInst(m,f,_), staticTF(t,f).
reachableT(t) :- reachableCM(_,m), MgetStatFldInst(m,_,f), staticTF(t,f).
reachableT(t) :- classT(t), reachableT(s), sub(s,t).

rootCM(0,0).
rootCM(0,m) :- reachableT(t), clinitTM(t,m).
CMCM(c,m,d,n) :- CICM(c,i,d,n), MI(m,i).

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=soft-argCopy-dlog

.include "I.dom"
.include "M.dom"
.include "V.dom"
.include "Z.dom"

.bddvarorder I0xM0_V0xV1_Z0xZ1

###
# Relations
###

IM(i:I,m:M) input
IinvkArg(i:I0,n:Z0,v:V1) input
MmethArg(m:M0,n:Z0,v:V0) input
kobjSenM(m:M) input

MspcMethArg(m:M,v:V) output
MordMethArg(m:M,z:Z,v:V) output

argCopy(i:I0,u:V1,m:M0,v:V0) output

###
# Constraints
###

MspcMethArg(m,v)   :- MmethArg(m,0,v), kobjSenM(m).
MordMethArg(m,0,v) :- MmethArg(m,0,v), !MspcMethArg(m,v).
MordMethArg(m,z,v) :- MmethArg(m,z,v), z!=0.

argCopy(i,u,m,v) :- IM(i,m), IinvkArg(i,z,u), MordMethArg(m,z,v).

================================================================================

package chord.analyses.alias;

import java.io.File;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import gnu.trove.list.array.TIntArrayList;

import joeq.Class.jq_ClassInitializer;
import joeq.Class.jq_Type;
import joeq.Class.jq_Field;
import joeq.Class.jq_Method;
import joeq.Compiler.Quad.ControlFlowGraph;
import joeq.Compiler.Quad.Inst;
import joeq.Compiler.Quad.Quad;
import joeq.Compiler.Quad.Operator;
import joeq.Compiler.Quad.Operator.New;
import joeq.Compiler.Quad.Operator.NewArray;
import joeq.Compiler.Quad.Operator.MultiNewArray;
import joeq.Compiler.Quad.Operator.Invoke.InvokeStatic;
import joeq.Compiler.Quad.RegisterFactory;
import joeq.Compiler.Quad.RegisterFactory.Register;
import chord.util.Utils;
import chord.bddbddb.Rel.RelView;
import chord.analyses.alloc.DomH;
import chord.analyses.invk.DomI;
import chord.analyses.method.DomM;
import chord.analyses.var.DomV;
import chord.program.Program;
import chord.project.Config;
import chord.project.Chord;
import chord.project.ClassicProject;
import chord.project.Messages;
import chord.project.OutDirUtils;
import chord.project.analyses.JavaAnalysis;
import chord.project.analyses.ProgramRel;
import chord.util.ArraySet;
import chord.util.graph.IGraph;
import chord.util.graph.MutableGraph;

/**
 * Analysis for pre-computing abstract contexts.
 * <p>
 * The goal of this analysis is to translate client-specified inputs concerning the desired kind of context sensitivity
 * into relations that are subsequently consumed by context-sensitive points-to and call-graph analyses.
 * <p>
 * This analysis allows:
 * <ul>
 *   <li>each method to be analyzed using a different kind of context sensitivity, namely, one of context insensitivity,
 *       k-CFA, k-object-sensitivity, and copy-context-sensitivity;</li>
 *   <li>each local variable to be analyzed context sensitively or insensitively; and</li>
 *   <li>a different 'k' value to be used for each object allocation site and method call site.</li>
 * </ul>
 * Recognized system properties:
 * <ul>
 *   <li>chord.inst.ctxt.kind: the kind of context sensitivity to use for each instance method (and all its locals).
 *       One of 'ci' (context insensitive), 'cs' (k-CFA), or 'co' (k-object-sensitive).  Default is 'ci'.</li>
 *   <li>chord.stat.ctxt.kind: the kind of context sensitivity to use for each static method (and all its locals).
 *       One of 'ci' (context insensitive), 'cs' (k-CFA), or 'co' (copy-context-sensitive).  Default is 'ci'.</li>
 *   <li>chord.ctxt.kind: the kind of context sensitivity to use for each method (and all its locals).
 *       One of 'ci', 'cs', or 'co'.  Serves as shorthand for properties chord.inst.ctxt.kind and chord.stat.ctxt.kind.</li>
 *   <li>chord.kobj.k and chord.kcfa.k: the 'k' value to use for each object allocation site and each method call site, 
 *       respectively.  Default is 0.</li>
 * </ul>
 * <p>
 * This analysis outputs the following domains and relations:
 * <ul>
 *   <li>C: domain containing all abstract contexts</li>
 *   <li>CC: each (c,c2) such that c2 is all but the last element of context c</li>
 *   <li>CH: each (c,h) such that object allocation site h is the last element of abstract context c</li>
 *   <li>CI: each (c,i) such that call site i is the last element of abstract context c</li>
 *   <li>CVC: each (c,v,o) such that local v might point to object o in context c of its declaring method</li>
 *   <li>CFC: each (o1,f,o2) such that instance field f of object o1 might point to object o2</li>
 *   <li>FC: each (f,o) such that static field f may point to object o</li>
 *   <li>CICM: each (c,i,c2,m) if invocation i in context c can reach method m (in context c2)</li>
 *   <li>rootCM: each (c,m) such that method m is an entry method in context c</li>
 *   <li>reachableCM: each (c,m) such that method m can be called in context c</li>
 * </ul>
 * 
 * @author Mayur Naik (mhn@cs.stanford.edu)
 */
@Chord(name = "ctxts-java",
       consumes = { "IM", "VH" },
       produces = { "C", "CC", "CH", "CI", "epsilonV", "epsilonM", "kcfaSenM", "kobjSenM", "ctxtCpyM" },
       namesOfTypes = { "C" },
       types = { DomC.class }
)
public class CtxtsAnalysis extends JavaAnalysis {
    private static final Set<Ctxt> emptyCtxtSet = Collections.emptySet();
    private static final Set<jq_Method> emptyMethSet = Collections.emptySet();
    private static final Quad[] emptyElems = new Quad[0];

    // includes all methods in domain
    private Set<Ctxt>[] methToCtxts;
    
    private TIntArrayList[] methToClrSites;  // ctxt kind is KCFASEN
    private TIntArrayList[] methToRcvSites;  // ctxt kind is KOBJSEN
    private Set<jq_Method>[] methToClrMeths; // ctxt kind is CTXTCPY
    
    private Set<Ctxt> epsilonCtxtSet;

    public static final int CTXTINS = 0;  // abbr ci; must be 0
    public static final int KOBJSEN = 1;  // abbr co
    public static final int KCFASEN = 2;  // abbr cs
    public static final int CTXTCPY = 3;  // abbr cc

    private int[] ItoM;
    private int[] HtoM;
    private Quad[] ItoQ;
    private Quad[] HtoQ;

    private jq_Method mainMeth;
    private boolean[] isCtxtSenV; // indexed by domV
    private int[] methKind;       // indexed by domM
    private int[] kobjValue;      // indexed by domH
    private int[] kcfaValue;      // indexed by domI

    private int instCtxtKind;
    private int statCtxtKind;

    private DomV domV;
    private DomM domM;
    private DomI domI;
    private DomH domH;
    private DomC domC;

    private ProgramRel relIM;
    private ProgramRel relVH;

    private ProgramRel relCC;
    private ProgramRel relCH;
    private ProgramRel relCI;
    
    private ProgramRel relEpsilonM;
    private ProgramRel relKcfaSenM;
    private ProgramRel relKobjSenM;
    private ProgramRel relCtxtCpyM;
    private ProgramRel relEpsilonV;

    // Reflection rels
    private ProgramRel relObjNewInstIM;
    private ProgramRel relConNewInstIM;

    public void run() {
        domV = (DomV) ClassicProject.g().getTrgt("V");
        domI = (DomI) ClassicProject.g().getTrgt("I");
        domM = (DomM) ClassicProject.g().getTrgt("M");
        domH = (DomH) ClassicProject.g().getTrgt("H");
        domC = (DomC) ClassicProject.g().getTrgt("C");

        relIM = (ProgramRel) ClassicProject.g().getTrgt("IM");
        relVH = (ProgramRel) ClassicProject.g().getTrgt("VH");

		relObjNewInstIM = (ProgramRel) ClassicProject.g().getTrgt("objNewInstIM");
		relConNewInstIM = (ProgramRel) ClassicProject.g().getTrgt("conNewInstIM");
        
        relCC = (ProgramRel) ClassicProject.g().getTrgt("CC");
        relCH = (ProgramRel) ClassicProject.g().getTrgt("CH");
        relCI = (ProgramRel) ClassicProject.g().getTrgt("CI");
        relEpsilonM = (ProgramRel) ClassicProject.g().getTrgt("epsilonM");
        relKcfaSenM = (ProgramRel) ClassicProject.g().getTrgt("kcfaSenM");
        relKobjSenM = (ProgramRel) ClassicProject.g().getTrgt("kobjSenM");
        relCtxtCpyM = (ProgramRel) ClassicProject.g().getTrgt("ctxtCpyM");
        relEpsilonV = (ProgramRel) ClassicProject.g().getTrgt("epsilonV");

        mainMeth = Program.g().getMainMethod();

        String ctxtKindStr = System.getProperty("chord.ctxt.kind", "ci");
        Config.check(ctxtKindStr, new String[] { "ci", "cs", "co" }, "chord.ctxt.kind");
        String instCtxtKindStr = System.getProperty("chord.inst.ctxt.kind", ctxtKindStr);
        Config.check(instCtxtKindStr, new String[] { "ci", "cs", "co" }, "chord.inst.ctxt.kind");
        String statCtxtKindStr = System.getProperty("chord.stat.ctxt.kind", ctxtKindStr);
        Config.check(statCtxtKindStr, new String[] { "ci", "cs", "co" }, "chord.stat.ctxt.kind");
        if (instCtxtKindStr.equals("ci")) {
            instCtxtKind = CTXTINS;
        } else if (instCtxtKindStr.equals("cs")) {
            instCtxtKind = KCFASEN;
        } else
            instCtxtKind = KOBJSEN;
        if (statCtxtKindStr.equals("ci")) {
            statCtxtKind = CTXTINS;
        } else if (statCtxtKindStr.equals("cs")) {
            statCtxtKind = KCFASEN;
        } else
            statCtxtKind = CTXTCPY;

        int kobjK = Integer.getInteger("chord.kobj.k", 1);
        assert (kobjK > 0);
        int kcfaK = Integer.getInteger("chord.kcfa.k", 0);
        // assert (kobjK <= kcfaK+1)

        int numV = domV.size();
        int numM = domM.size();
        int numA = domH.getLastI() + 1;
        int numI = domI.size();

		{
			// set k values to use for sites: build arrays kobjValue and kcfaValue

			kobjValue = new int[numA];
			HtoM = new int[numA]; // Which method is h located in?
			HtoQ = new Quad[numA];
			for (int i = 1; i < numA; i++) {
				kobjValue[i] = kobjK;
				Quad site = (Quad) domH.get(i);
				jq_Method m = site.getMethod();
				HtoM[i] = domM.indexOf(m);
				HtoQ[i] = site;
			}
			kcfaValue = new int[numI];
			ItoM = new int[numI]; // Which method is i located in?
			ItoQ = new Quad[numI];
			for (int i = 0; i < numI; i++) {
				kcfaValue[i] = kcfaK;
				Quad invk = domI.get(i);
				jq_Method m = invk.getMethod();
				ItoM[i] = domM.indexOf(m);
				ItoQ[i] = invk;
			}

        	String kvals = System.getProperty("chord.kvals", null);
			if (kvals != null) {
				String[] list = kvals.split(",");
				for (String elem : list) {
                    // elem must have format: H32 2 or I3 5
                    String[] tokens = elem.split(" ");         
                    assert (tokens.length == 2);
                    int idx = Integer.parseInt(tokens[0].substring(1));
                    int val = Integer.parseInt(tokens[1]);
                    switch (tokens[0].charAt(0)) {
                    case 'H': kobjValue[idx] = val; break;
                    case 'I': kcfaValue[idx] = val; break;
                    default: assert false;
                    }
                }
			}
		}

		{
			// populate arrays methKind and isCtxtSenV

        	// set the kind of context sensitivity to use for various methods
			methKind = new int[numM];
			for (int mIdx = 0; mIdx < numM; mIdx++) {
				jq_Method m = domM.get(mIdx);
				int kind;
				if (m == mainMeth || m instanceof jq_ClassInitializer || m.isAbstract())
					kind = CTXTINS;
				else
					kind = m.isStatic() ? statCtxtKind : instCtxtKind;
				methKind[mIdx] = kind;
			}
			// override default kind of context-sensitivity if defined in a file
			String ctxts = System.getProperty("chord.ctxts", null);
			if (ctxts != null) {
				String[] list = ctxts.split(",");
				for (String elem : list) {
					// elem must have format: M23 [0|1|2|3]
					String[] tokens = elem.split(" ");
                    assert (tokens.length == 2);
                    int idx = Integer.parseInt(tokens[0].substring(1));
                    int val = Integer.parseInt(tokens[1]);
					methKind[idx] = val;
				}
			}

			// set the context sensitivity of variables inside each method based on
			// the context sensitivity of that method
			isCtxtSenV = new boolean[numV];
			for (int mIdx = 0; mIdx < numM; mIdx++) {
				if (methKind[mIdx] != CTXTINS) {
					jq_Method m = domM.get(mIdx);
					ControlFlowGraph cfg = m.getCFG();
					RegisterFactory rf = cfg.getRegisterFactory();
					for (Object o : rf) {
						Register v = (Register) o;
						if (v.getType().isReferenceType()) {
							int vIdx = domV.indexOf(v);
							// locals unused by any quad in cfg are not in domain V
							if (vIdx != -1) {
								isCtxtSenV[vIdx] = true;
							}
						}
					}
				}
			}
		}

        validate();

        relIM.load();
		relVH.load();
		relObjNewInstIM.load();
		relConNewInstIM.load();

        Ctxt epsilon = domC.setCtxt(emptyElems);
        epsilonCtxtSet = new ArraySet<Ctxt>(1);
        epsilonCtxtSet.add(epsilon);

        methToCtxts = new Set[numM];

        methToClrSites = new TIntArrayList[numM];
        methToRcvSites = new TIntArrayList[numM];
        methToClrMeths = new Set[numM];

        // Do the heavy crunching
        doAnalysis();

        relIM.close();
        relVH.close();

        // Populate domC
        for (int iIdx = 0; iIdx < numI; iIdx++) {
            Quad invk = (Quad) domI.get(iIdx);
            jq_Method meth = invk.getMethod();
            int mIdx = domM.indexOf(meth);
            Set<Ctxt> ctxts = methToCtxts[mIdx];
            int k = kcfaValue[iIdx];
            for (Ctxt oldCtxt : ctxts) {
                Quad[] oldElems = oldCtxt.getElems();
                Quad[] newElems = combine(k, invk, oldElems);
                domC.setCtxt(newElems);
            }
        }
        for (int hIdx = 1; hIdx < numA; hIdx++) {
            Quad inst = (Quad) domH.get(hIdx);
            jq_Method meth = inst.getMethod();
            int mIdx = domM.indexOf(meth);
            Set<Ctxt> ctxts = methToCtxts[mIdx];
            int k = kobjValue[hIdx];
            for (Ctxt oldCtxt : ctxts) {
                Quad[] oldElems = oldCtxt.getElems();
                Quad[] newElems = combine(k, inst, oldElems);
                domC.setCtxt(newElems);
            }
        }
        domC.save();

        int numC = domC.size();

        relCC.zero();
        relCI.zero();
        for (int iIdx = 0; iIdx < numI; iIdx++) {
            Quad invk = (Quad) domI.get(iIdx);
            jq_Method meth = invk.getMethod();
            Set<Ctxt> ctxts = methToCtxts[domM.indexOf(meth)];
            int k = kcfaValue[iIdx];
            for (Ctxt oldCtxt : ctxts) {
                Quad[] oldElems = oldCtxt.getElems();
                Quad[] newElems = combine(k, invk, oldElems);
                Ctxt newCtxt = domC.setCtxt(newElems);
                relCC.add(oldCtxt, newCtxt);
                relCI.add(newCtxt, invk);
            }
        }
        relCI.save();

        assert (domC.size() == numC);

        relCH.zero();
        for (int hIdx = 1; hIdx < numA; hIdx++) {
            Quad inst = (Quad) domH.get(hIdx);
            jq_Method meth = inst.getMethod();
            int mIdx = domM.indexOf(meth);
            Set<Ctxt> ctxts = methToCtxts[mIdx];
            int k = kobjValue[hIdx];
            for (Ctxt oldCtxt : ctxts) {
                Quad[] oldElems = oldCtxt.getElems();
                Quad[] newElems = combine(k, inst, oldElems);
                Ctxt newCtxt = domC.setCtxt(newElems);
                relCC.add(oldCtxt, newCtxt);
                relCH.add(newCtxt, inst);
            }
        }
        relCH.save();

        assert (domC.size() == numC);

        relCC.save();

        relEpsilonM.zero();
        relKcfaSenM.zero();
        relKobjSenM.zero();
        relCtxtCpyM.zero();
        for (int mIdx = 0; mIdx < numM; mIdx++) {
            int kind = methKind[mIdx];
            switch (kind) {
            case CTXTINS:
                relEpsilonM.add(mIdx);
                break;
            case KOBJSEN:
                relKobjSenM.add(mIdx);
                break;
            case KCFASEN:
                relKcfaSenM.add(mIdx);
                break;
            case CTXTCPY:
                relCtxtCpyM.add(mIdx);
                break;
            default:
                assert false;
            }
        }
        relEpsilonM.save();
        relKcfaSenM.save();
        relKobjSenM.save();
        relCtxtCpyM.save();

        relEpsilonV.zero();
        for (int v = 0; v < numV; v++) {
            if (!isCtxtSenV[v])
                relEpsilonV.add(v);
        }
        relEpsilonV.save();
    }

    private void validate() {
        // check that the main jq_Method and each class initializer method and each method without a body
		// is not asked to be analyzed context sensitively.
        int numM = domM.size();
        for (int m = 0; m < numM; m++) {
            int kind = methKind[m];
            if (kind != CTXTINS) {
                jq_Method meth = domM.get(m);
                assert (meth != mainMeth);
                assert (!(meth instanceof jq_ClassInitializer));
                if (kind == KOBJSEN) {
                    assert (!meth.isStatic());
                } else if (kind == CTXTCPY) {
                    assert (meth.isStatic());
                }
            }
        }
        // check that no variable in a context insensitive method is asked to be treated context sensitively.
        int numV = domV.size();
        for (int v = 0; v < numV; v++) {
            if (isCtxtSenV[v]) {
                Register var = domV.get(v);
                jq_Method meth = domV.getMethod(var);
                int m = domM.indexOf(meth);
                int kind = methKind[m];
                assert (kind != CTXTINS);
            }
        }
    }

    private void doAnalysis() {
        Set<jq_Method> roots = new HashSet<jq_Method>();
        Map<jq_Method, Set<jq_Method>> methToPredsMap = new HashMap<jq_Method, Set<jq_Method>>();
        for (int mIdx = 0; mIdx < domM.size(); mIdx++) { // For each method...
            jq_Method meth = domM.get(mIdx);
            int kind = methKind[mIdx];
            switch (kind) {
            case CTXTINS:
            {
                roots.add(meth);
                methToPredsMap.put(meth, emptyMethSet);
                methToCtxts[mIdx] = epsilonCtxtSet;
                break;
            }
            case KCFASEN:
            {
                Set<jq_Method> predMeths = new HashSet<jq_Method>();
                TIntArrayList clrSites = new TIntArrayList();
                for (Quad invk : getCallers(meth)) {
                    predMeths.add(invk.getMethod()); // Which method can point to this method...?
                    int iIdx = domI.indexOf(invk);
                    clrSites.add(iIdx); // sites that can call me
                }
                methToClrSites[mIdx] = clrSites;
                methToPredsMap.put(meth, predMeths);
                methToCtxts[mIdx] = emptyCtxtSet;
                break;
            }
            case KOBJSEN:
            {
                Set<jq_Method> predMeths = new HashSet<jq_Method>();
                TIntArrayList rcvSites = new TIntArrayList();
                ControlFlowGraph cfg = meth.getCFG();
                Register thisVar = cfg.getRegisterFactory().get(0);
                Iterable<Quad> pts = getPointsTo(thisVar);
                for (Quad inst : pts) {
                    predMeths.add(inst.getMethod());
                    int hIdx = domH.indexOf(inst);
                    rcvSites.add(hIdx);
                }
                methToRcvSites[mIdx] = rcvSites;
                methToPredsMap.put(meth, predMeths);
                methToCtxts[mIdx] = emptyCtxtSet;
                break;
            }
            case CTXTCPY:
            {
                Set<jq_Method> predMeths = new HashSet<jq_Method>();
                for (Quad invk : getCallers(meth)) {
                    predMeths.add(invk.getMethod());
                }
                methToClrMeths[mIdx] = predMeths;
                methToPredsMap.put(meth, predMeths);
                methToCtxts[mIdx] = emptyCtxtSet;
                break;
            }
            default:
                assert false;
            }
        }
        process(roots, methToPredsMap);
    }

    // Compute all the contexts that each method can be called in
    private void process(Set<jq_Method> roots, Map<jq_Method, Set<jq_Method>> methToPredsMap) {
        IGraph<jq_Method> graph = new MutableGraph<jq_Method>(roots, methToPredsMap, null);
        List<Set<jq_Method>> sccList = graph.getTopSortedSCCs();
        int n = sccList.size();
        if (Config.verbose >= 2)
            System.out.println("numSCCs: " + n);
        for (int i = 0; i < n; i++) { // For each SCC...
            Set<jq_Method> scc = sccList.get(i);
            if (Config.verbose >= 2)
                System.out.println("Processing SCC #" + i + " of size: " + scc.size());
            if (scc.size() == 1) { // Singleton
                jq_Method cle = scc.iterator().next();
                if (roots.contains(cle))
                    continue;
                if (!graph.hasEdge(cle, cle)) {
                    int cleIdx = domM.indexOf(cle);
                    methToCtxts[cleIdx] = getNewCtxts(cleIdx);
                    continue;
                }
            }
            for (jq_Method cle : scc) {
                assert (!roots.contains(cle));
            }
            boolean changed = true;
            for (int count = 0; changed; count++) { // Iterate...
                if (Config.verbose >= 2)
                    System.out.println("\tIteration  #" + count);
                changed = false;
                for (jq_Method cle : scc) { // For each node (method) in SCC
                    int mIdx = domM.indexOf(cle);
                    Set<Ctxt> newCtxts = getNewCtxts(mIdx);
                    if (!changed) {
                        Set<Ctxt> oldCtxts = methToCtxts[mIdx];
                        if (newCtxts.size() > oldCtxts.size())
                            changed = true;
                        else {
                            for (Ctxt ctxt : newCtxts) {
                                if (!oldCtxts.contains(ctxt)) {
                                    changed = true;
                                    break;
                                }
                            }
                        }
                    }
                    methToCtxts[mIdx] = newCtxts;
                }
            }
        }
    }

    private Iterable<Quad> getPointsTo(Register var) {
        RelView view = relVH.getView();
        view.selectAndDelete(0, var);
        return view.getAry1ValTuples();
    }

    private Iterable<Quad> getCallers(jq_Method meth) {
		RelView view = relIM.getView();
		view.selectAndDelete(1, meth);
		Set<Quad> ret = new ArraySet<Quad>();
		for (Object q : view.getAry1ValTuples())
			ret.add((Quad) q);

		view = relObjNewInstIM.getView();
		view.selectAndDelete(1, meth);
		for (Object q : view.getAry1ValTuples())
			ret.add((Quad) q);

		view = relConNewInstIM.getView();
		view.selectAndDelete(1, meth);
		for (Object q : view.getAry1ValTuples())
			ret.add((Quad) q);

		return ret;
    }

    private Quad[] combine(int k, Quad inst, Quad[] elems) {
        int oldLen = elems.length;
        int newLen = Math.min(k - 1, oldLen) + 1;
        Quad[] newElems = new Quad[newLen];
        if (newLen > 0) newElems[0] = inst;
        if (newLen > 1)
            System.arraycopy(elems, 0, newElems, 1, newLen - 1);
        return newElems;
    }

    private Set<Ctxt> getNewCtxts(int cleIdx) { // Update contexts for this method (callee)
        final Set<Ctxt> newCtxts = new HashSet<Ctxt>();
        int kind = methKind[cleIdx];
        switch (kind) {
        case KCFASEN:
        {
            TIntArrayList invks = methToClrSites[cleIdx]; // which call sites point to me
            int n = invks.size();
            for (int i = 0; i < n; i++) {
                int iIdx = invks.get(i);
                Quad invk = ItoQ[iIdx];
                int k = kcfaValue[iIdx];
                int clrIdx = ItoM[iIdx];
                Set<Ctxt> clrCtxts = methToCtxts[clrIdx]; // method of caller
                for (Ctxt oldCtxt : clrCtxts) {
                    Quad[] oldElems = oldCtxt.getElems();
                    Quad[] newElems = combine(k, invk, oldElems); // Append
                    Ctxt newCtxt = domC.setCtxt(newElems);
                    newCtxts.add(newCtxt);
                }
            }
            break;
        }
        case KOBJSEN:
        {
            TIntArrayList rcvs = methToRcvSites[cleIdx];
            int n = rcvs.size();
            for (int i = 0; i < n; i++) {
                int hIdx = rcvs.get(i);
                Quad rcv = HtoQ[hIdx];
                int k = kobjValue[hIdx];
                int clrIdx = HtoM[hIdx];
                Set<Ctxt> rcvCtxts = methToCtxts[clrIdx];
                for (Ctxt oldCtxt : rcvCtxts) {
                    Quad[] oldElems = oldCtxt.getElems();
                    Quad[] newElems = combine(k, rcv, oldElems);
                    Ctxt newCtxt = domC.setCtxt(newElems);
                    newCtxts.add(newCtxt);
                }
            }
            break;
        }
        case CTXTCPY:
        {
            Set<jq_Method> clrs = methToClrMeths[cleIdx];
            for (jq_Method clr : clrs) {
                int clrIdx = domM.indexOf(clr);
                Set<Ctxt> clrCtxts = methToCtxts[clrIdx];
                newCtxts.addAll(clrCtxts);
            }
            break;
        }
        default:
            assert false;
        }
        return newCtxts;
    }

    public static String getCspaKind() {
        String ctxtKindStr = System.getProperty("chord.ctxt.kind", "ci");
        String instCtxtKindStr = System.getProperty("chord.inst.ctxt.kind", ctxtKindStr);
        String statCtxtKindStr = System.getProperty("chord.stat.ctxt.kind", ctxtKindStr);
        int instCtxtKind, statCtxtKind;
        if (instCtxtKindStr.equals("ci")) {
            instCtxtKind = CtxtsAnalysis.CTXTINS;
        } else if (instCtxtKindStr.equals("cs")) {
            instCtxtKind = CtxtsAnalysis.KCFASEN;
        } else if (instCtxtKindStr.equals("co")) {
            instCtxtKind = CtxtsAnalysis.KOBJSEN;
        } else
            throw new RuntimeException();
        if (statCtxtKindStr.equals("ci")) {
            statCtxtKind = CtxtsAnalysis.CTXTINS;
        } else if (statCtxtKindStr.equals("cs")) {
            statCtxtKind = CtxtsAnalysis.KCFASEN;
        } else if (statCtxtKindStr.equals("co")) {
            statCtxtKind = CtxtsAnalysis.CTXTCPY;
        } else
            throw new RuntimeException();
        String cspaKind;
        if (instCtxtKind == CtxtsAnalysis.CTXTINS && statCtxtKind == CtxtsAnalysis.CTXTINS)
            cspaKind = "cspa-0cfa-dlog";
        else if (instCtxtKind == CtxtsAnalysis.KOBJSEN && statCtxtKind == CtxtsAnalysis.CTXTCPY)
            cspaKind = "cspa-kobj-dlog";
        else if (instCtxtKind == CtxtsAnalysis.KCFASEN && statCtxtKind == CtxtsAnalysis.KCFASEN)
            cspaKind = "cspa-kcfa-dlog";
        else
            cspaKind = "cspa-hybrid-dlog";
        return cspaKind;
    }

    jq_Type h2t(Quad h) {
        Operator op = h.getOperator();
        if (op instanceof New) 
            return New.getType(h).getType();
        else if (op instanceof NewArray)
            return NewArray.getType(h).getType();
        else if (op instanceof MultiNewArray)
            return MultiNewArray.getType(h).getType();
        else
            return null;
    }
    String hstr(Quad h) {
        String path = new File(h.toJavaLocStr()).getName();
        jq_Type t = h2t(h);
        return path+"("+(t == null ? "?" : t.shortName())+")";
    }
    String istr(Quad i) {
        String path = new File(i.toJavaLocStr()).getName();
        jq_Method m = InvokeStatic.getMethod(i).getMethod();
        return path+"("+m.getName()+")";
    }
    String jstr(Quad j) { return isAlloc(j) ? hstr(j) : istr(j); }
    String estr(Quad e) {
        String path = new File(e.toJavaLocStr()).getName();
        Operator op = e.getOperator();
        return path+"("+op+")";
    }
    String cstr(Ctxt c) {
        StringBuilder buf = new StringBuilder();
        buf.append('{');
        for (int i = 0; i < c.length(); i++) {
            if (i > 0) buf.append(" | ");
            Quad q = c.get(i);
            buf.append(isAlloc(q) ? hstr(q) : istr(q));
        }
        buf.append('}');
        return buf.toString();
    }
    String fstr(jq_Field f) { return f.getDeclaringClass()+"."+f.getName(); }
    String vstr(Register v) { return v+"@"+mstr(domV.getMethod(v)); }
    String mstr(jq_Method m) { return m.getDeclaringClass().shortName()+"."+m.getName(); }
    boolean isAlloc(Quad q) { return domH.indexOf(q) != -1; }
}

================================================================================

# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Context-insensitive may-alias/call-graph analysis.

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=cipa-0cfa-dlog

.include "T.dom"
.include "F.dom"
.include "M.dom"
.include "I.dom"
.include "H.dom"
.include "V.dom"
.include "Z.dom"

.bddvarorder I0xM0xM1_T0_V0xV1_T1_H0_F0_H1_Z0

###
# Relations
###

VT(v:V0,t:T0) input
HT(h:H0,t:T1) input
cha(n:M1,t:T1,m:M0) input
sub(t1:T1,t2:T0) input
MmethArg(m:M0,n:Z0,v:V0) input
MmethRet(m:M0,n:Z0,v:V1) input
IinvkArg0(i:I0,v:V1) input
IinvkArg(i:I0,n:Z0,v:V1) input
IinvkRet(i:I0,n:Z0,v:V0) input
MI(m:M,i:I) input
statIM(i:I,m:M) input
specIM(i:I,m:M) input
virtIM(i:I,m:M) input

MobjValAsgnInst(m:M0,l:V0,h:H0) input
MobjVarAsgnInst(m:M0,l:V0,r:V1) input
MgetInstFldInst(m:M0,l:V0,b:V1,f:F0) input
MputInstFldInst(m:M0,b:V0,f:F0,r:V1) input
MgetStatFldInst(m:M0,l:V0,f:F0) input
MputStatFldInst(m:M0,f:F0,r:V) input

clsForNameIT(i:I0,t:T0) input
objNewInstIH(i:I0,h:H0) input
objNewInstIM(i:I0,m:M0) input
conNewInstIH(i:I0,h:H0) input
conNewInstIM(i:I0,m:M0) input
aryNewInstIH(i:I0,h:H0) input

classT(t:T) input
staticTM(t:T,m:M) input
staticTF(t:T,f:F) input
clinitTM(t:T,m:M) input

#MclsValAsgnInst(m:M0,v:V0,t:T0) input
#MgetClassInvkInst(m:M0,i:I0) input
#clsTH(t:T0,h:H0) input
#objTH(t:T0,h:H0) input

IHM(i:I,h:H,m:M) output
VV(v1:V,v2:V)
specIMV(i:I,m:M,v:V)

objValAsgnInst(l:V,h:H) 
objVarAsgnInst(l:V,r:V) 
getInstFldInst(l:V,b:V,f:F) 
putInstFldInst(b:V,f:F,r:V) 
getStatFldInst(l:V,f:F) 
putStatFldInst(f:F,r:V) 

reachableT(t:T) output
VHfilter(v:V,h:H) output
VH(v:V,h:H) output
FH(f:F,h:H) output
HFH(h1:H,f:F,h2:H) output
rootM(m:M) output
reachableI(i:I) output
reachableM(m:M) output
IM(i:I,m:M) output
MM(m:M,n:M) output

###
# Constraints
###

VHfilter(v,h) :- VT(v,t), HT(h,s), sub(s,t).
VHfilter(_,0).

IHM(i,h,m2) :- virtIM(i,m1), HT(h,t), cha(m1,t,m2).

# base cases: each root method and each class initializer is reachable
reachableM(0).
reachableM(m) :- reachableT(t), clinitTM(t,m).
# inductive case
reachableM(m) :- IM(_,m).

reachableI(i) :- MI(m,i), reachableM(m).

# possibly-multiple-target call sites
IM(i,m) :- reachableI(i), IinvkArg0(i,v), VH(v,h), IHM(i,h,m).
# definitely-single-target call sites
specIMV(i,m,v) :- specIM(i,m), IinvkArg0(i,v).

IM(i,m) :- reachableI(i), specIMV(i,m,v), VH(v,_).
IM(i,m) :- reachableI(i), statIM(i,m).

# Reflection
# IM(i,m) :- reachableI(i), objNewInstIM(i,m).
# IM(i,m) :- reachableI(i), conNewInstIM(i,m).

# arguments and return/throw variables
VV(v,u) :- IinvkArg(i,z,u), IM(i,m), MmethArg(m,z,v).
VV(u,v) :- IinvkRet(i,z,u), IM(i,m), MmethRet(m,z,v).

VH(u,h) :- VV(u,v), VH(v,h), VHfilter(u,h).

objValAsgnInst(l,h)   :- reachableM(m), MobjValAsgnInst(m,l,h).
objVarAsgnInst(l,r)   :- reachableM(m), MobjVarAsgnInst(m,l,r).
getInstFldInst(l,b,f) :- reachableM(m), MgetInstFldInst(m,l,b,f).
putInstFldInst(b,f,r) :- reachableM(m), MputInstFldInst(m,b,f,r).
getStatFldInst(l,f)   :- reachableM(m), MgetStatFldInst(m,l,f).
putStatFldInst(f,r)   :- reachableM(m), MputStatFldInst(m,f,r).

reachableT(t) :- reachableI(i), conNewInstIH(i,h), HT(h,t).
reachableT(t) :- reachableI(i), objNewInstIH(i,h), HT(h,t).
reachableT(t) :- reachableI(i), clsForNameIT(i,t).

reachableM(m) :- reachableI(i), objNewInstIM(i,m).
reachableM(m) :- reachableI(i), conNewInstIM(i,m).

VH(v,h)  :- reachableI(i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), VHfilter(v,h).
VH(v,h)  :- reachableI(i), objNewInstIH(i,h), IinvkRet(i,0,v), VHfilter(v,h).
VH(v,h2) :- reachableI(i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), VH(u,h), HFH(h,0,h2), VHfilter(v,h2).
VH(v,h)  :- reachableI(i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), VHfilter(v,h).
VH(v,h)  :- reachableI(i), conNewInstIH(i,h), IinvkRet(i,0,v), VHfilter(v,h).
VH(v,h)  :- reachableI(i), aryNewInstIH(i,h), IinvkRet(i,0,v), VHfilter(v,h).

VH(l,h) :- objValAsgnInst(l,h), VHfilter(l,h).
VH(l,h) :- objVarAsgnInst(l,r), VH(r,h), VHfilter(l,h).
VH(l,h2) :- getInstFldInst(l,b,f), VH(b,h1), HFH(h1,f,h2), VHfilter(l,h2). split
HFH(h1,f,h2) :- putInstFldInst(b,f,r), VH(b,h1), VH(r,h2). split
VH(l,h) :- getStatFldInst(l,f), FH(f,h), VHfilter(l,h).
FH(f,h) :- putStatFldInst(f,r), VH(r,h).

## See: http://java.sun.com/docs/books/jls/second_edition/html/execution.doc.html
## Section 12.4 Initialization of Classes and Interfaces
## A class or interface type T will be initialized immediately before
## the first occurrence of any one of the following:

# 1. T is a class and an instance of T is created.
# this handles both normal allocation and reflective allocation
reachableT(t) :- objValAsgnInst(_,h), HT(h,t).
# 2. T is a class and a static method declared by T is invoked
reachableT(t) :- reachableM(m), staticTM(t,m).
# 3. A static field declared by T is assigned. 
reachableT(t) :- putStatFldInst(f,_), staticTF(t,f).
# 4. A static field declared by T is used and the reference to the
#    field is not a compile-time constant.
reachableT(t) :- getStatFldInst(_,f), staticTF(t,f).
# 5. Before a class is initialized, its direct superclass must be
#    initialized.
reachableT(t) :- classT(t), reachableT(s), sub(s,t).

rootM(0).
rootM(m) :- reachableT(t), clinitTM(t,m).
MM(m,n) :- IM(i,n), MI(m,i).

