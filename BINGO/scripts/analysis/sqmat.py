#!/usr/bin/env python3

# Given a ranked list of alarms, along with their ground truths (for e.g. as a stats.txt file generated by an AC run)
# and a list of grounded clauses (i.e. an appropriate named_cons_all.txt file), produces the two square matrices:

# 1. For each pair of alarms, a1, a2, the number of shared ancestor clauses: |ancClauses(a1) /\ ancClauses(a2)|
# 2. For each pair of alarms, a1, a2, the number of alarms in the difference of ancestor clauses:
#    |ancClauses(a2) - ancClauses(a1)| (a1 is indexed by the row, a2 is indexed by the column).

# The rows and columns of this output are arranged according to the order of their production in the stats.txt file.

# ./scripts/analysis/sqmat.py stats.txt named_cons_all.txt.pruned eq.mat diff.mat

import logging
import re
import sys

statsFileName = sys.argv[1]
consAllFileName = sys.argv[2]
eqOutFileName = sys.argv[3]
diffOutFileName = sys.argv[4]

onlyTrue = 'onlytrue' in sys.argv
onlyFalse = 'onlyfalse' in sys.argv
assert not (onlyTrue and onlyFalse)

logging.basicConfig(level=logging.INFO, \
                    format="[%(asctime)s] %(levelname)s [%(name)s.%(funcName)s:%(lineno)d] %(message)s", \
                    datefmt="%H:%M:%S")

########################################################################################################################
# 1. Accept input

stats = [ line.strip() for line in open(statsFileName) ]
stats = [ line.split('\t') for line in stats ]
statsHeader = stats[0]
stats = stats[1:]
statsTupleIndex = statsHeader.index('Tuple')
statsGroundIndex = statsHeader.index('Ground')
stats = [ { 'Tuple': line[statsTupleIndex], 'Ground': line[statsGroundIndex] == 'TrueGround' } for line in stats ]
statsDict = { line['Tuple']: line['Ground'] for line in stats }

allClauses = set()
allRuleNames = {}

for line in open(consAllFileName):
    line = line.strip()
    clause = [ literal.strip() for literal in re.split(':|, ', line) ]
    ruleName, clause = clause[0], tuple(clause[1:])

    allRuleNames[clause] = ruleName
    allClauses.add(clause)

def lit2Tuple(literal):
    return literal if not literal.startswith('NOT ') else literal[len('NOT '):]

def clause2Antecedents(clause):
    return [ lit2Tuple(literal) for literal in clause[:-1] ]

def clause2Consequent(clause):
    consequent = clause[-1]
    assert not consequent.startswith('NOT ')
    return consequent

allTuples = { lit2Tuple(literal) for clause in allClauses for literal in clause }
allConsequents = { clause2Consequent(clause) for clause in allClauses }
allInputTuples = allTuples - allConsequents

logging.info('Loaded {0} clauses.'.format(len(allClauses)))
logging.info('Discovered {0} tuples.'.format(len(allTuples)))
logging.info('Discovered {0} consequents.'.format(len(allConsequents)))
logging.info('Discovered {0} input tuples.'.format(len(allInputTuples)))

########################################################################################################################
# 2. Define the ancestry

derivingClauses = { t: set() for t in allTuples }
for clause in allClauses:
    consequent = clause2Consequent(clause)
    derivingClauses[consequent].add(clause)

def ancTuples(t):
    ans = { t }
    unprocessedTuples = { t }
    while len(unprocessedTuples) > 0:
        tprime = unprocessedTuples.pop()
        for clause in derivingClauses[tprime]:
            for t in clause2Antecedents(clause):
                if t not in ans:
                    ans.add(t)
                    unprocessedTuples.add(t)
    return ans

def ancClauses(t):
    ats = ancTuples(t)
    ans = { clause for t in ats for clause in derivingClauses[t] }
    return ans

########################################################################################################################
# 3. Compute the matrix of shared ancestor clauses

headerRow = [ t['Tuple'] for t in stats ]
if onlyTrue: headerRow = [ t for t in headerRow if statsDict[t] ]
elif onlyFalse: headerRow = [ t for t in headerRow if not statsDict[t] ]
headerRow = [ 'X' ] + headerRow

eqMat = [ headerRow ]
for t1 in stats:
    t1 = t1['Tuple']

    if onlyTrue and not statsDict[t1]: continue
    elif onlyFalse and statsDict[t1]: continue

    newRow = [ statsDict[t1] ]
    t1AncClauses = ancClauses(t1)
    for t2 in stats:
        t2 = t2['Tuple']

        if onlyTrue and not statsDict[t2]: continue
        elif onlyFalse and statsDict[t2]: continue

        t2AncClauses = ancClauses(t2)
        sharedClauses = t1AncClauses & t2AncClauses
        newRow.append(len(sharedClauses))
    eqMat.append(newRow)

# Print
with open(eqOutFileName, 'w') as eqOutFile:
    for row in eqMat:
        row = [ str(val) for val in row ]
        print('\t'.join(row), file=eqOutFile)
logging.info('Finished computing matrix of shared ancestor clauses!')

########################################################################################################################
# 4. Compute the matrix of ancestor clause differences

headerRow = [ t['Tuple'] for t in stats ]
if onlyTrue: headerRow = [ t for t in headerRow if statsDict[t] ]
elif onlyFalse: headerRow = [ t for t in headerRow if not statsDict[t] ]
headerRow = [ 'X' ] + headerRow

diffMat = [ headerRow ]
for t1 in stats:
    t1 = t1['Tuple']

    if onlyTrue and not statsDict[t1]: continue
    elif onlyFalse and statsDict[t1]: continue

    newRow = [ t1 ]
    t1AncClauses = ancClauses(t1)
    for t2 in stats:
        t2 = t2['Tuple']

        if onlyTrue and not statsDict[t2]: continue
        elif onlyFalse and statsDict[t2]: continue

        t2AncClauses = ancClauses(t2)
        diffClauses = t2AncClauses - t1AncClauses
        newRow.append(len(diffClauses))
    diffMat.append(newRow)

# Print
with open(diffOutFileName, 'w') as diffOutFile:
    for row in diffMat:
        row = [ str(val) for val in row ]
        print('\t'.join(row), file=diffOutFile)
logging.info('Finished computing matrix of ancestor clause differences!')
